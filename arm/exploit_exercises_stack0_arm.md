## Source Code
```c
#include <stdio.h>
#include <unistd.h>
#include <stdio.h>

int main(int argc, char **argv)
{
    volatile int modified;
    char buffer[64];
    modified = 0;
    
    gets(buffer);
    
    if (modified != 0) {
        printf("You have changed the 'modified' variables!\n");
    } else {
        printf("Try again?!\n");
    }
    
    return 0;
}
```

## Walkthrough 

```nasm
STMFD   SP!, {R11,LR}
ADD     R11, SP, #4
SUB     SP, SP, #0x50
STR     R0, [R11,#var_50]
STR     R1, [R11,#var_54]
MOV     R3, #0
STR     R3, [R11,#var_8]
SUB     R3, R11, #-s
MOV     R0, R3          ; s
BL      gets
LDR     R3, [R11,#var_8]
CMP     R3, #0
BEQ     loc_8460
```

This is pretty typical in function prologue, for making space on the stack for local variables.  
```nasm
SUB     SP, SP, #0x50
```

Store ```argc``` and ```argv``` onto the stack. There location on the stack is referenced by ```r11``` , which is ARM's frame pointer.
```nasm
STR     R0, [R11,#var_50]
STR     R1, [R11,#var_54]
```
Move ```0``` into ```r3```, then store that on the stack.  This is the ```modified``` local variable.
```nasm
MOV     R3, #0
STR     R3, [R11,#var_8]
```
